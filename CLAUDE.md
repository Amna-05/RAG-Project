# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A multi-user RAG (Retrieval-Augmented Generation) system with FastAPI backend and Next.js frontend. Users can upload documents, which are processed into embeddings stored in Pinecone, then query them using natural language with responses generated by Google Gemini.

## Common Commands

### Backend (Python)

```bash
# Run development server (from project root)
python run.py

# Or directly with uvicorn
uvicorn rag.main:app --reload --host 127.0.0.1 --port 8000

# Run with src in path manually
set PYTHONPATH=src && uvicorn rag.main:app --reload

# Database migrations
alembic upgrade head              # Apply all migrations
alembic revision --autogenerate -m "description"  # Create migration

# Run tests
pytest
pytest tests/test_documents.py    # Single test file
pytest -k "test_name"             # Single test by name
```

### Frontend (Next.js)

```bash
cd frontend/rag-frontend

npm run dev      # Development server (port 3000) with Turbopack
npm run build    # Production build
npm run start    # Start production server
npm run lint     # ESLint
```

### Dependencies

```bash
# Backend - uses uv package manager
uv sync                    # Install dependencies
uv add <package>          # Add new dependency

# Frontend
cd frontend/rag-frontend
npm install
```

## Architecture

### Backend Structure (`src/rag/`)

```
src/rag/
├── main.py              # FastAPI app entry point, middleware, lifespan
├── core/
│   ├── config.py        # Pydantic settings (loads from .env)
│   ├── database.py      # Async SQLAlchemy setup (asyncpg + PostgreSQL)
│   └── security.py      # JWT creation/verification, password hashing
├── api/
│   ├── deps.py          # Dependency injection (get_current_user from cookie)
│   └── v1/
│       ├── auth.py      # Auth endpoints: register, login, refresh, logout
│       └── rag.py       # RAG endpoints: upload, documents, chat, history
├── services/
│   ├── auth_service.py  # Auth business logic
│   ├── rag_service.py   # Document processing orchestration
│   ├── document_service.py
│   └── llm_service.py   # Gemini integration wrapper
├── crud/                # Database operations (user, token, document)
├── models/              # SQLAlchemy ORM models (user, document, token)
├── schemas/             # Pydantic request/response schemas
├── documents.py         # Text extraction (PDF, DOCX, TXT) + chunking
├── embeddings.py        # sentence-transformers embeddings with file cache
├── vectorstore.py       # Pinecone operations (store, search, delete)
└── llm_integration.py   # Direct Gemini calls for RAG responses
```

### Frontend Structure (`frontend/rag-frontend/src/`)

```
src/
├── app/
│   ├── (auth)/          # Auth group: login, register pages
│   ├── (dashboard)/     # Protected routes: dashboard
│   ├── layout.tsx       # Root layout
│   └── page.tsx         # Landing page
├── components/
│   ├── auth/            # LoginForm, RegisterForm
│   ├── layout/          # Header, Sidebar
│   └── ui/              # shadcn components
└── lib/
    ├── api/
    │   ├── client.ts    # Axios instance with 401 refresh interceptor
    │   └── auth.ts      # Auth API calls
    ├── hooks/useAuth.ts # Auth hook
    ├── store/authStore.ts # Zustand store with localStorage
    └── types/           # TypeScript interfaces
```

### Data Flow

1. **Document Upload**: File → `data/uploads/{user_id}/` → DB record (status=pending)
2. **Processing**: Text extraction → Chunking (1000 chars, 200 overlap) → Embeddings (384-dim)
3. **Storage**: Vectors + metadata → Pinecone (namespace per user)
4. **Query**: Question → Embed → Pinecone similarity search (top 5) → Gemini generates answer

### Authentication

- JWT tokens stored in httpOnly cookies (not localStorage)
- Access token: 30 min, Refresh token: 7 days
- Frontend axios interceptor auto-refreshes on 401
- Cookie settings: `secure=True` in production, `samesite=lax`

### Rate Limiting

API endpoints are protected by rate limiting using SlowAPI with Redis (production) or in-memory (development) storage.

**Limits by Endpoint Type:**
| Endpoint | Limit | Key | Purpose |
|----------|-------|-----|---------|
| `POST /chat` | 10/minute | User ID | Prevent LLM cost abuse |
| `POST /upload` | 2/10 minutes | User ID | Control processing load |
| `POST /login, /register, /refresh` | 5/minute | IP address | Prevent brute-force |

**Excluded Endpoints (no rate limit):**
- `/health`, `/docs`, `/redoc`, `/openapi.json`

**Error Response (HTTP 429):**
```json
{
  "detail": "Rate limit exceeded. Please try again later.",
  "retry_after": 45,
  "error_code": "RATE_LIMIT_EXCEEDED"
}
```

**Headers:** All rate-limited responses include:
- `X-RateLimit-Limit`: Max requests in window
- `X-RateLimit-Remaining`: Requests left
- `X-RateLimit-Reset`: Seconds until reset
- `Retry-After`: Seconds to wait (on 429)

**Configuration** (in `.env`):
```bash
RATE_LIMIT_STORAGE=memory        # or "redis" for production
REDIS_URL=redis://localhost:6379/0
RATE_LIMIT_ENABLED=true
```

**Fail-Open Behavior:** If Redis is unavailable, rate limiting falls back to in-memory storage with a warning log (requests are NOT blocked).

## Key Configuration

All settings in `src/rag/core/config.py`, loaded from `.env`:

- `DATABASE_URL`: PostgreSQL async connection string
- `PINECONE_API_KEY`, `PINECONE_INDEX_NAME`: Vector database
- `GOOGLE_API_KEY`: For Gemini LLM
- `JWT_SECRET_KEY`, `JWT_REFRESH_SECRET_KEY`: Auth secrets
- `CORS_ORIGINS`: Must include frontend URL for cookie auth

## API Endpoints

- `POST /api/v1/auth/register` - Create account + auto-login
- `POST /api/v1/auth/login` - Email/password login
- `POST /api/v1/auth/refresh` - Refresh access token
- `POST /api/v1/auth/logout` - Revoke refresh token
- `POST /api/v1/rag/upload` - Upload document (multipart)
- `GET /api/v1/rag/documents` - List user's documents
- `POST /api/v1/rag/chat` - Query with `{question, session_id?}`
- `GET /api/v1/rag/chat/history/{session_id}` - Conversation history

API docs at `http://localhost:8000/docs` (Swagger) or `/redoc`.

## Database

- PostgreSQL with async SQLAlchemy (asyncpg driver)
- Models: User, Document, DocumentChunk, ChatMessage, RefreshToken
- Each user has `pinecone_namespace` for data isolation
- Alembic for migrations (scripts in `alembic/`)

## File Storage

- Uploads: `data/uploads/{user_id}/{filename}`
- Embedding cache: `data/embeddings_cache/` (MD5-hashed)
- Max file size: 10MB
- Allowed types: .pdf, .docx, .txt, .json

## Spec-Driven Development (SpecKit)

This project uses a spec-driven development workflow via SpecKit. All features follow this process:

### Workflow Commands

```bash
/speckit.specify <description>   # Create feature spec from description
/speckit.clarify                 # Ask clarification questions for spec
/speckit.plan                    # Generate implementation plan + ADRs
/speckit.tasks                   # Break plan into executable tasks
/speckit.implement               # Execute tasks from tasks.md
```

### Directory Structure

```
.specify/                        # SpecKit tooling (DO NOT MODIFY)
├── memory/constitution.md       # Project principles & rules
├── scripts/                     # Automation scripts
└── templates/                   # Spec, plan, task templates

specs/                           # Feature specifications (OUTPUT)
└── ###-feature-name/
    ├── spec.md                  # What to build (user stories, requirements)
    ├── plan.md                  # How to build (architecture, phases)
    ├── research.md              # Technology decisions
    ├── data-model.md            # Entities and relationships
    ├── tasks.md                 # Executable task list
    ├── contracts/               # API schemas (OpenAPI)
    ├── adrs/                    # Architectural Decision Records
    └── checklists/              # Quality validation
```

### Key Principles

1. **Spec before code**: Every feature starts with `/speckit.specify`
2. **User stories drive tasks**: Tasks organized by user story for independent testing
3. **Constitution compliance**: All features must pass constitution checks
4. **ADRs for decisions**: Major technical choices documented with rationale
5. **Incremental delivery**: Each user story is independently deployable

### Current Features

| Branch | Status | Description |
|--------|--------|-------------|
| 001-api-rate-limiting | Implemented | Rate limiting for API abuse protection |

## Active Technologies
- Python 3.12+ + FastAPI, SlowAPI, Redis, Pydantic (001-api-rate-limiting)
- Redis (rate limit counters) + PostgreSQL (audit logging) (001-api-rate-limiting)

## Recent Changes
- 001-api-rate-limiting: Added Python 3.12+ + FastAPI, SlowAPI, Redis, Pydantic
- Added spec-driven development workflow with SpecKit
